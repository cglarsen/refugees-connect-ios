//
//  CreateShelterViewController.swift
//  RefugeConnect
//
//  Created by Christian Graver on 02/03/2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Daman Clean Swift Xcode Templates
//  with inspiration from http://clean-swift.com
//

import UIKit
import JTAppleCalendar
import MapKit

class CreateShelterViewController: UIViewController {
	
	// MARK: - Outlets
	@IBOutlet var mapView: MKMapView! {
		didSet {
			mapView.delegate = self
		}
	}
	
	@IBOutlet var mapCenterView: UIView! {
		didSet {
			mapCenterView.backgroundColor = .red.withAlphaComponent(0.7)
		}
	}
	@IBOutlet var mapCenterViewWidth: NSLayoutConstraint!
	@IBOutlet var startDayCalendarView: JTACMonthView! {
		didSet {
			startDayCalendarView.calendarDelegate = self
			startDayCalendarView.calendarDataSource = self
			startDayCalendarView.scrollDirection = .horizontal
			startDayCalendarView.scrollingMode   = .stopAtEachCalendarFrame
			startDayCalendarView.allowsMultipleSelection = true
			startDayCalendarView.allowsRangedSelection = true
			startDayCalendarView.showsHorizontalScrollIndicator = false
		}
	}
	
	@IBOutlet var selectedStartDateLabel: UILabel!
	@IBOutlet var selectedEndDateLabel: UILabel!
	@IBOutlet var numberAdultsTextField: UITextField! {
		didSet {
			numberAdultsTextField.addTarget(self, action: #selector(CreateShelterViewController.textFieldDidChange(_:)), for: .editingChanged)
		}
	}
	@IBOutlet var numberChildrenTextField: UITextField! {
		didSet {
			numberChildrenTextField.addTarget(self, action: #selector(CreateShelterViewController.textFieldDidChange(_:)), for: .editingChanged)
		}
	}
	@IBOutlet var numberBabiesTextField: UITextField! {
		didSet {
			numberBabiesTextField.addTarget(self, action: #selector(CreateShelterViewController.textFieldDidChange(_:)), for: .editingChanged)
		}
	}
	@IBOutlet var maxDurationTextField: UITextField! {
		didSet {
			maxDurationTextField.addTarget(self, action: #selector(CreateShelterViewController.textFieldDidChange(_:)), for: .editingChanged)
		}
	}
	
	
	// MARK: - Properties
	private var server: ServerRepository!
	private var createShelter: ShelterVM = ShelterVM() {
		didSet {
			print("Changed shelter: \(createShelter)")
		}
	}
	
	// Calendar controls
	lazy var dateformatter: DateFormatter = {
		let formatter = DateFormatter()
		formatter.dateFormat = "yyyy MM dd"
		return formatter
	}()
	
	var firstDate: Date? {
		didSet {
			createShelter.startDate = firstDate
			if selectedStartDateLabel != nil {
				if let date = firstDate {
					selectedStartDateLabel.text = dateformatter.string(from: date)
				} else {
					secondDate = nil
					selectedStartDateLabel.text = nil
				}
				
				
			}
		}
	}
	var secondDate: Date? {
		didSet {
			createShelter.endDate = secondDate
			if selectedEndDateLabel != nil {
				if let date = secondDate {
					selectedEndDateLabel.text = dateformatter.string(from: date)
				} else {
					selectedEndDateLabel.text = nil
				}
			}
		}
	}
	var twoDatesAlreadySelected: Bool {
		return firstDate != nil && startDayCalendarView.selectedDates.count > 1
	}
	
	// MARK: - Init
	class func instantiate(server: ServerRepository) -> CreateShelterViewController {
		let name = "\(CreateShelterViewController.self)"
		let storyboard = UIStoryboard(name: name, bundle: nil)
		let vc = storyboard.instantiateViewController(withIdentifier: name) as! CreateShelterViewController
		vc.server = server
		return vc
	}
	
	// MARK: - View lifecycle
	override func viewDidLoad() {
		super.viewDidLoad()
		setupView()
	}
	
	// MARK: - Actions
	@objc func textFieldDidChange(_ textField: UITextField) {
		guard let text = textField.text,
					let number = Int(text) else {
						return
					}
		
		switch textField {
		case numberAdultsTextField:
			self.createShelter.accommodatesAdults = number
		case numberChildrenTextField:
			self.createShelter.accommodatesChildren = number
		case numberBabiesTextField:
			self.createShelter.accommodatesBabies = number
		case maxDurationTextField:
			self.createShelter.maxDurationWeeks = number
		default:
			break
		}
	}
	
	
	@IBAction func nextPressed(_ sender: Any) {
		let contactVC = ContactInformationViewController.instantiate(server: server, shelter: createShelter)
		self.navigationController?.pushViewController(contactVC, animated: true)
	}
	
	// MARK: - Misc
	private func setupView() {
		
	}
}

// MARK: - JTAppleCalendarViewDataSource
extension CreateShelterViewController: JTACMonthViewDataSource {
	func configureCalendar(_ calendar: JTACMonthView) -> ConfigurationParameters {
		let formatter = DateFormatter()
		formatter.dateFormat = "yyyy MM dd"
		let startDate = Date()
		let endDate = Date().addingTimeInterval(TimeInterval(60*60*24*365))
		return ConfigurationParameters(startDate: startDate, endDate: endDate)
	}
}

// MARK: - JTAppleCalendarViewDelegate
extension CreateShelterViewController: JTACMonthViewDelegate {
	func calendar(_ calendar: JTACMonthView, didSelectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) {
		if firstDate != nil {
			calendar.selectDates(from: firstDate!, to: date,  triggerSelectionDelegate: false, keepSelectionIfMultiSelectionAllowed: true)
			secondDate = date
		} else {
			firstDate = date
		}
		configureCell(view: cell, cellState: cellState)
	}
	
	func calendar(_ calendar: JTACMonthView, didDeselectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) {
		configureCell(view: cell, cellState: cellState)
	}
	
	func calendar(_ calendar: JTACMonthView, shouldSelectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) -> Bool {
		if twoDatesAlreadySelected && cellState.selectionType != .programatic || firstDate != nil && date < calendar.selectedDates[0] {
			firstDate = nil
			let retval = !calendar.selectedDates.contains(date)
			calendar.deselectAllDates()
			return retval
		}
		return true
	}
	
	func calendar(_ calendar: JTACMonthView, shouldDeselectDate date: Date, cell: JTACDayCell?, cellState: CellState, indexPath: IndexPath) -> Bool {
		if twoDatesAlreadySelected && cellState.selectionType != .programatic {
			firstDate = nil
			calendar.deselectAllDates()
			return false
		}
		return true
	}
	
	func calendar(_ calendar: JTACMonthView, cellForItemAt date: Date, cellState: CellState, indexPath: IndexPath) -> JTACDayCell {
		let cell = calendar.dequeueReusableJTAppleCell(withReuseIdentifier: "dateCell", for: indexPath) as! SimpleDateCell
		self.calendar(calendar, willDisplay: cell, forItemAt: date, cellState: cellState, indexPath: indexPath)
		return cell
	}
	
	func calendar(_ calendar: JTACMonthView, willDisplay cell: JTACDayCell, forItemAt date: Date, cellState: CellState, indexPath: IndexPath) {
		configureCell(view: cell, cellState: cellState)
	}
	
	private func configureCell(view: JTACDayCell?, cellState: CellState) {
		guard let cell = view as? SimpleDateCell  else { return }
		cell.dateLabel.text = cellState.text
		handleCellTextColor(cell: cell, cellState: cellState)
		handleCellSelected(cell: cell, cellState: cellState)
	}
	
	private func handleCellTextColor(cell: SimpleDateCell , cellState: CellState) {
		if cellState.dateBelongsTo == .thisMonth {
			cell.dateLabel.textColor = UIColor.black
		} else {
			cell.dateLabel.textColor = UIColor.gray
		}
	}
	
	private func handleCellSelected(cell: SimpleDateCell, cellState: CellState) {
		cell.selectedView.isHidden = !cellState.isSelected
		switch cellState.selectedPosition() {
		case .left:
			cell.selectedView.layer.cornerRadius = 20
			cell.selectedView.layer.maskedCorners = [.layerMinXMaxYCorner, .layerMinXMinYCorner]
		case .middle:
			cell.selectedView.layer.cornerRadius = 0
			cell.selectedView.layer.maskedCorners = []
		case .right:
			cell.selectedView.layer.cornerRadius = 20
			cell.selectedView.layer.maskedCorners = [.layerMaxXMaxYCorner, .layerMaxXMinYCorner]
		case .full:
			cell.selectedView.layer.cornerRadius = 20
			cell.selectedView.layer.maskedCorners = [.layerMaxXMaxYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMinXMinYCorner]
		default: break
		}
	}
	
	func calendar(_ calendar: JTACMonthView, headerViewForDateRange range: (start: Date, end: Date), at indexPath: IndexPath) -> JTACMonthReusableView {
		let formatter = DateFormatter()  // Declare this outside, to avoid instancing this heavy class multiple times.
		formatter.dateFormat = "MMM yyyy"
		
		let header = calendar.dequeueReusableJTAppleSupplementaryView(withReuseIdentifier: "MonthHeader", for: indexPath) as! MonthHeader
		header.monthTitle.text = formatter.string(from: range.start)
		return header
	}
	
	func calendarSizeForMonths(_ calendar: JTACMonthView?) -> MonthSize? {
		return MonthSize(defaultSize: 50)
	}
}

extension CreateShelterViewController: MKMapViewDelegate {
	func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
		let zoomWidth = mapView.visibleMapRect.size.width
		let zoomFactor = Int(log2(zoomWidth)) - 9
		print("...REGION DID CHANGE: ZOOM FACTOR \(zoomFactor)")
		var mapMarkerWidth: CGFloat = 0
		switch zoomFactor {
		case 0:
			mapMarkerWidth = 300
		case 1:
			mapMarkerWidth = 250
		case 2:
			mapMarkerWidth = 225
		case 3:
			mapMarkerWidth = 200
		case 4:
			mapMarkerWidth = 175
		case 5:
			mapMarkerWidth = 150
		case 6:
			mapMarkerWidth = 125
		case 7:
			mapMarkerWidth = 100
		case 8:
			mapMarkerWidth = 90
		case 9:
			mapMarkerWidth = 80
		case 10:
			mapMarkerWidth = 70
		case 11:
			mapMarkerWidth = 60
		case 12:
			mapMarkerWidth = 50
		case 13:
			mapMarkerWidth = 50
		default:
			mapMarkerWidth = zoomFactor <= 0 ? 300 : 50
		}
		self.view.layoutIfNeeded()
		UIView.animate(withDuration: 0.15) {
			self.mapCenterView.layer.cornerRadius = mapMarkerWidth/2
			self.mapCenterViewWidth.constant = mapMarkerWidth
			self.view.layoutIfNeeded()
		}
	}
	
	func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
		createShelter.coarseLocation = mapView.centerCoordinate
	}
}

extension CreateShelterViewController: UITextFieldDelegate {
	func textFieldDidEndEditing(_ textField: UITextField) {
		guard let text = textField.text,
					let number = Int(text) else {
						return
					}
		
		switch textField {
		case numberAdultsTextField:
			self.createShelter.accommodatesAdults = number
		case numberChildrenTextField:
			self.createShelter.accommodatesChildren = number
		case numberBabiesTextField:
			self.createShelter.accommodatesBabies = number
		case maxDurationTextField:
			self.createShelter.maxDurationWeeks = number
		default:
			break
		}
	}
}
